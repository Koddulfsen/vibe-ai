#!/usr/bin/env python3
"""
Code Generation Template System
Comprehensive templates for generating production-ready code
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import json
import os


@dataclass
class CodeTemplate:
    """Represents a code generation template"""
    name: str
    language: str
    framework: str
    template_type: str  # api, model, service, test, etc.
    template: str
    variables: List[str]
    dependencies: List[str]
    
    def render(self, context: Dict[str, Any]) -> str:
        """Render template with given context"""
        rendered = self.template
        for var, value in context.items():
            placeholder = f"{{{var}}}"
            rendered = rendered.replace(placeholder, str(value))
        return rendered


class CodeGenerationTemplates:
    """Comprehensive code generation template system"""
    
    def __init__(self):
        self.templates = self._initialize_templates()
        
    def _initialize_templates(self) -> Dict[str, List[CodeTemplate]]:
        """Initialize all code generation templates"""
        return {
            "python_fastapi": self._get_python_fastapi_templates(),
            "python_django": self._get_python_django_templates(),
            "javascript_express": self._get_javascript_express_templates(),
            "javascript_react": self._get_javascript_react_templates(),
            "go_gin": self._get_go_gin_templates(),
            "rust_actix": self._get_rust_actix_templates(),
            "sql": self._get_sql_templates(),
            "docker": self._get_docker_templates(),
            "kubernetes": self._get_kubernetes_templates(),
            "testing": self._get_testing_templates()
        }
    
    def _get_python_fastapi_templates(self) -> List[CodeTemplate]:
        """FastAPI templates"""
        return [
            CodeTemplate(
                name="fastapi_crud_router",
                language="python",
                framework="fastapi",
                template_type="api",
                template='''"""
{resource_name} CRUD Router
Auto-generated by vibe.ai
"""

from fastapi import APIRouter, HTTPException, Depends, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime

from database import get_db
from models.{resource_lower} import {resource_name}
from schemas.{resource_lower} import (
    {resource_name}Create,
    {resource_name}Update,
    {resource_name}Response,
    {resource_name}List
)
from services.{resource_lower}_service import {resource_name}Service
from auth.dependencies import get_current_user
from utils.pagination import PaginationParams
from utils.filters import {resource_name}Filters

router = APIRouter(
    prefix="/{resource_plural}",
    tags=["{resource_plural}"],
    dependencies=[Depends(get_current_user)]
)

@router.get("/", response_model={resource_name}List)
async def list_{resource_plural}(
    pagination: PaginationParams = Depends(),
    filters: {resource_name}Filters = Depends(),
    db: Session = Depends(get_db)
):
    """
    List all {resource_plural} with pagination and filtering
    """
    service = {resource_name}Service(db)
    items, total = service.list(
        skip=pagination.skip,
        limit=pagination.limit,
        filters=filters
    )
    
    return {{
        "items": items,
        "total": total,
        "page": pagination.page,
        "pages": (total + pagination.limit - 1) // pagination.limit
    }}

@router.get("/{{{resource_lower}_id}}", response_model={resource_name}Response)
async def get_{resource_lower}(
    {resource_lower}_id: str,
    db: Session = Depends(get_db)
):
    """
    Get a specific {resource_lower} by ID
    """
    service = {resource_name}Service(db)
    item = service.get({resource_lower}_id)
    
    if not item:
        raise HTTPException(status_code=404, detail="{resource_name} not found")
    
    return item

@router.post("/", response_model={resource_name}Response, status_code=201)
async def create_{resource_lower}(
    {resource_lower}_data: {resource_name}Create,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Create a new {resource_lower}
    """
    service = {resource_name}Service(db)
    
    # Add audit fields
    data = {resource_lower}_data.dict()
    data["created_by"] = current_user.id
    data["created_at"] = datetime.utcnow()
    
    item = service.create(data)
    return item

@router.put("/{{{resource_lower}_id}}", response_model={resource_name}Response)
async def update_{resource_lower}(
    {resource_lower}_id: str,
    {resource_lower}_data: {resource_name}Update,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Update an existing {resource_lower}
    """
    service = {resource_name}Service(db)
    
    # Check if exists
    existing = service.get({resource_lower}_id)
    if not existing:
        raise HTTPException(status_code=404, detail="{resource_name} not found")
    
    # Add audit fields
    data = {resource_lower}_data.dict(exclude_unset=True)
    data["updated_by"] = current_user.id
    data["updated_at"] = datetime.utcnow()
    
    item = service.update({resource_lower}_id, data)
    return item

@router.delete("/{{{resource_lower}_id}}", status_code=204)
async def delete_{resource_lower}(
    {resource_lower}_id: str,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Delete a {resource_lower}
    """
    service = {resource_name}Service(db)
    
    # Check if exists
    existing = service.get({resource_lower}_id)
    if not existing:
        raise HTTPException(status_code=404, detail="{resource_name} not found")
    
    # Soft delete with audit
    service.soft_delete({resource_lower}_id, current_user.id)
    return None

@router.post("/{{{resource_lower}_id}}/restore", response_model={resource_name}Response)
async def restore_{resource_lower}(
    {resource_lower}_id: str,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Restore a soft-deleted {resource_lower}
    """
    service = {resource_name}Service(db)
    item = service.restore({resource_lower}_id, current_user.id)
    
    if not item:
        raise HTTPException(status_code=404, detail="{resource_name} not found")
    
    return item
''',
                variables=["resource_name", "resource_lower", "resource_plural"],
                dependencies=["fastapi", "sqlalchemy", "pydantic"]
            ),
            
            CodeTemplate(
                name="fastapi_service",
                language="python",
                framework="fastapi",
                template_type="service",
                template='''"""
{resource_name} Service Layer
Auto-generated by vibe.ai
"""

from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from typing import List, Optional, Tuple, Dict, Any
from datetime import datetime
import uuid

from models.{resource_lower} import {resource_name}
from repositories.{resource_lower}_repository import {resource_name}Repository
from core.exceptions import BusinessLogicException
from utils.cache import cache_result, invalidate_cache
from utils.events import emit_event
from utils.validators import validate_{resource_lower}_data

class {resource_name}Service:
    """
    Business logic for {resource_name} operations
    """
    
    def __init__(self, db: Session):
        self.db = db
        self.repository = {resource_name}Repository(db)
    
    @cache_result(ttl=300)  # Cache for 5 minutes
    def list(self, skip: int = 0, limit: int = 100, 
             filters: Optional[Dict[str, Any]] = None) -> Tuple[List[{resource_name}], int]:
        """
        List {resource_plural} with pagination and filtering
        """
        query = self.repository.get_query()
        
        # Apply filters
        if filters:
            query = self._apply_filters(query, filters)
        
        # Get total count
        total = query.count()
        
        # Apply pagination
        items = query.offset(skip).limit(limit).all()
        
        return items, total
    
    @cache_result(ttl=300)
    def get(self, {resource_lower}_id: str) -> Optional[{resource_name}]:
        """
        Get a single {resource_lower} by ID
        """
        return self.repository.get_by_id({resource_lower}_id)
    
    @invalidate_cache(pattern="{resource_lower}:*")
    def create(self, data: Dict[str, Any]) -> {resource_name}:
        """
        Create a new {resource_lower}
        """
        # Validate data
        validate_{resource_lower}_data(data)
        
        # Generate ID if not provided
        if "id" not in data:
            data["id"] = str(uuid.uuid4())
        
        # Check for duplicates
        if self._check_duplicates(data):
            raise BusinessLogicException("Duplicate {resource_lower} detected")
        
        # Create entity
        item = self.repository.create(data)
        
        # Emit event
        emit_event("{resource_lower}.created", {{
            "id": item.id,
            "data": data
        }})
        
        return item
    
    @invalidate_cache(pattern="{resource_lower}:*")
    def update(self, {resource_lower}_id: str, data: Dict[str, Any]) -> {resource_name}:
        """
        Update an existing {resource_lower}
        """
        # Validate data
        validate_{resource_lower}_data(data, partial=True)
        
        # Get existing item
        item = self.repository.get_by_id({resource_lower}_id)
        if not item:
            raise BusinessLogicException("{resource_name} not found")
        
        # Update entity
        updated_item = self.repository.update({resource_lower}_id, data)
        
        # Emit event
        emit_event("{resource_lower}.updated", {{
            "id": {resource_lower}_id,
            "changes": data
        }})
        
        return updated_item
    
    @invalidate_cache(pattern="{resource_lower}:*")
    def soft_delete(self, {resource_lower}_id: str, deleted_by: str) -> bool:
        """
        Soft delete a {resource_lower}
        """
        item = self.repository.get_by_id({resource_lower}_id)
        if not item:
            raise BusinessLogicException("{resource_name} not found")
        
        # Check if can be deleted
        if not self._can_delete(item):
            raise BusinessLogicException("Cannot delete {resource_lower} due to existing dependencies")
        
        # Soft delete
        success = self.repository.soft_delete({resource_lower}_id, deleted_by)
        
        if success:
            emit_event("{resource_lower}.deleted", {{
                "id": {resource_lower}_id,
                "deleted_by": deleted_by
            }})
        
        return success
    
    @invalidate_cache(pattern="{resource_lower}:*")
    def restore(self, {resource_lower}_id: str, restored_by: str) -> Optional[{resource_name}]:
        """
        Restore a soft-deleted {resource_lower}
        """
        item = self.repository.restore({resource_lower}_id, restored_by)
        
        if item:
            emit_event("{resource_lower}.restored", {{
                "id": {resource_lower}_id,
                "restored_by": restored_by
            }})
        
        return item
    
    def _apply_filters(self, query, filters: Dict[str, Any]):
        """
        Apply filters to query
        """
        # Example filters implementation
        if "search" in filters and filters["search"]:
            search_term = f"%{{filters['search']}}%"
            query = query.filter(
                or_(
                    {resource_name}.name.ilike(search_term),
                    {resource_name}.description.ilike(search_term)
                )
            )
        
        if "status" in filters and filters["status"]:
            query = query.filter({resource_name}.status == filters["status"])
        
        if "created_after" in filters and filters["created_after"]:
            query = query.filter({resource_name}.created_at >= filters["created_after"])
        
        return query
    
    def _check_duplicates(self, data: Dict[str, Any]) -> bool:
        """
        Check for duplicate entries
        """
        # Implement duplicate checking logic
        # Example: check if name already exists
        if "name" in data:
            existing = self.repository.get_by_field("name", data["name"])
            return existing is not None
        return False
    
    def _can_delete(self, item: {resource_name}) -> bool:
        """
        Check if item can be deleted
        """
        # Implement dependency checking
        # Example: check if item has related records
        return True  # Placeholder
''',
                variables=["resource_name", "resource_lower", "resource_plural"],
                dependencies=["sqlalchemy", "redis", "events"]
            ),
            
            CodeTemplate(
                name="sqlalchemy_model",
                language="python",
                framework="sqlalchemy",
                template_type="model",
                template='''"""
{resource_name} SQLAlchemy Model
Auto-generated by vibe.ai
"""

from sqlalchemy import Column, String, Integer, Float, Boolean, DateTime, Text, JSON, ForeignKey, Index
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import datetime
import uuid

from database import Base
from models.mixins import TimestampMixin, SoftDeleteMixin, AuditMixin

class {resource_name}(Base, TimestampMixin, SoftDeleteMixin, AuditMixin):
    """
    {resource_name} model with full audit trail and soft delete
    """
    __tablename__ = "{table_name}"
    
    # Primary key
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    
    # Core fields
    {fields}
    
    # Relationships
    {relationships}
    
    # Indexes
    __table_args__ = (
        Index("idx_{table_name}_name", "name"),
        Index("idx_{table_name}_status", "status"),
        Index("idx_{table_name}_created_at", "created_at"),
        Index("idx_{table_name}_deleted_at", "deleted_at"),
    )
    
    # Validations
    @validates("email")
    def validate_email(self, key, email):
        """Validate email format"""
        if email and "@" not in email:
            raise ValueError("Invalid email format")
        return email
    
    @validates("status")
    def validate_status(self, key, status):
        """Validate status values"""
        valid_statuses = ["active", "inactive", "pending", "archived"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status. Must be one of: {{valid_statuses}}")
        return status
    
    # Hybrid properties
    @hybrid_property
    def is_active(self):
        """Check if record is active"""
        return self.status == "active" and self.deleted_at is None
    
    @hybrid_property
    def display_name(self):
        """Get display name"""
        return self.name or self.email or f"{self.__class__.__name__} {{self.id}}"
    
    # Methods
    def to_dict(self, include_relationships=False):
        """Convert model to dictionary"""
        data = {{
            "id": self.id,
            {dict_fields}
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }}
        
        if include_relationships:
            # Add relationship data
            {relationship_data}
        
        return data
    
    def __repr__(self):
        return f"<{resource_name}(id={{self.id}}, name={{self.name}})>"
''',
                variables=["resource_name", "table_name", "fields", "relationships", "dict_fields", "relationship_data"],
                dependencies=["sqlalchemy"]
            ),
            
            CodeTemplate(
                name="pydantic_schema",
                language="python",
                framework="pydantic",
                template_type="schema",
                template='''"""
{resource_name} Pydantic Schemas
Auto-generated by vibe.ai
"""

from pydantic import BaseModel, Field, validator, EmailStr, constr, conint
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum

class {resource_name}Status(str, Enum):
    """Status enumeration for {resource_name}"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    ARCHIVED = "archived"

class {resource_name}Base(BaseModel):
    """Base schema for {resource_name}"""
    {base_fields}
    
    class Config:
        orm_mode = True
        use_enum_values = True
        json_encoders = {{
            datetime: lambda v: v.isoformat()
        }}

class {resource_name}Create(BaseModel):
    """Schema for creating {resource_name}"""
    {create_fields}
    
    @validator("email")
    def email_must_be_valid(cls, v):
        if v and "@" not in v:
            raise ValueError("Invalid email format")
        return v
    
    @validator("name")
    def name_must_not_be_empty(cls, v):
        if v and not v.strip():
            raise ValueError("Name cannot be empty")
        return v

class {resource_name}Update(BaseModel):
    """Schema for updating {resource_name}"""
    {update_fields}
    
    class Config:
        orm_mode = True

class {resource_name}Response(BaseModel):
    """Schema for {resource_name} response"""
    id: str
    {response_fields}
    created_at: datetime
    updated_at: Optional[datetime]
    created_by: Optional[str]
    updated_by: Optional[str]
    
    class Config:
        orm_mode = True

class {resource_name}List(BaseModel):
    """Schema for paginated {resource_name} list"""
    items: List[{resource_name}Response]
    total: int
    page: int
    pages: int
    
    class Config:
        orm_mode = True

class {resource_name}Filters(BaseModel):
    """Schema for {resource_name} filters"""
    search: Optional[str] = Field(None, description="Search in name and description")
    status: Optional[{resource_name}Status] = None
    created_after: Optional[datetime] = None
    created_before: Optional[datetime] = None
    {filter_fields}
''',
                variables=["resource_name", "base_fields", "create_fields", "update_fields", "response_fields", "filter_fields"],
                dependencies=["pydantic"]
            ),
            
            CodeTemplate(
                name="pytest_test",
                language="python",
                framework="pytest",
                template_type="test",
                template='''"""
Tests for {resource_name}
Auto-generated by vibe.ai
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timedelta
import uuid

from main import app
from database import Base, get_db
from models.{resource_lower} import {resource_name}
from auth.utils import create_access_token

# Test database
SQLALCHEMY_DATABASE_URL = "sqlite:///./test_{resource_lower}.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={{"check_same_thread": False}})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create test database
Base.metadata.create_all(bind=engine)

def override_get_db():
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

app.dependency_overrides[get_db] = override_get_db

client = TestClient(app)

class Test{resource_name}CRUD:
    """Test {resource_name} CRUD operations"""
    
    @pytest.fixture
    def auth_headers(self):
        """Get authentication headers"""
        token = create_access_token({{"sub": "test_user_id", "email": "test@example.com"}})
        return {{"Authorization": f"Bearer {{token}}"}}
    
    @pytest.fixture
    def sample_{resource_lower}(self):
        """Create sample {resource_lower} data"""
        return {{
            {sample_data}
        }}
    
    def test_create_{resource_lower}(self, auth_headers, sample_{resource_lower}):
        """Test creating a new {resource_lower}"""
        response = client.post(
            "/{resource_plural}/",
            json=sample_{resource_lower},
            headers=auth_headers
        )
        
        assert response.status_code == 201
        data = response.json()
        assert data["name"] == sample_{resource_lower}["name"]
        assert "id" in data
        assert "created_at" in data
    
    def test_get_{resource_lower}(self, auth_headers, sample_{resource_lower}):
        """Test getting a specific {resource_lower}"""
        # First create
        create_response = client.post(
            "/{resource_plural}/",
            json=sample_{resource_lower},
            headers=auth_headers
        )
        {resource_lower}_id = create_response.json()["id"]
        
        # Then get
        response = client.get(
            f"/{resource_plural}/{{{resource_lower}_id}}",
            headers=auth_headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == {resource_lower}_id
        assert data["name"] == sample_{resource_lower}["name"]
    
    def test_list_{resource_plural}(self, auth_headers, sample_{resource_lower}):
        """Test listing {resource_plural} with pagination"""
        # Create multiple items
        for i in range(5):
            modified_data = sample_{resource_lower}.copy()
            modified_data["name"] = f"{{sample_{resource_lower}['name']}} {{i}}"
            client.post("/{resource_plural}/", json=modified_data, headers=auth_headers)
        
        # List with pagination
        response = client.get(
            "/{resource_plural}/?page=1&limit=3",
            headers=auth_headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert len(data["items"]) <= 3
        assert data["total"] >= 5
        assert "pages" in data
    
    def test_update_{resource_lower}(self, auth_headers, sample_{resource_lower}):
        """Test updating a {resource_lower}"""
        # Create
        create_response = client.post(
            "/{resource_plural}/",
            json=sample_{resource_lower},
            headers=auth_headers
        )
        {resource_lower}_id = create_response.json()["id"]
        
        # Update
        update_data = {{"name": "Updated Name", "description": "Updated description"}}
        response = client.put(
            f"/{resource_plural}/{{{resource_lower}_id}}",
            json=update_data,
            headers=auth_headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["name"] == "Updated Name"
        assert data["description"] == "Updated description"
    
    def test_delete_{resource_lower}(self, auth_headers, sample_{resource_lower}):
        """Test deleting a {resource_lower}"""
        # Create
        create_response = client.post(
            "/{resource_plural}/",
            json=sample_{resource_lower},
            headers=auth_headers
        )
        {resource_lower}_id = create_response.json()["id"]
        
        # Delete
        response = client.delete(
            f"/{resource_plural}/{{{resource_lower}_id}}",
            headers=auth_headers
        )
        
        assert response.status_code == 204
        
        # Verify deleted
        get_response = client.get(
            f"/{resource_plural}/{{{resource_lower}_id}}",
            headers=auth_headers
        )
        assert get_response.status_code == 404
    
    def test_search_{resource_plural}(self, auth_headers, sample_{resource_lower}):
        """Test searching {resource_plural}"""
        # Create with specific name
        sample_{resource_lower}["name"] = "Searchable Item"
        client.post("/{resource_plural}/", json=sample_{resource_lower}, headers=auth_headers)
        
        # Search
        response = client.get(
            "/{resource_plural}/?search=Searchable",
            headers=auth_headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert len(data["items"]) >= 1
        assert any("Searchable" in item["name"] for item in data["items"])
    
    def test_unauthorized_access(self, sample_{resource_lower}):
        """Test unauthorized access is blocked"""
        response = client.post("/{resource_plural}/", json=sample_{resource_lower})
        assert response.status_code == 401
    
    def test_invalid_data(self, auth_headers):
        """Test validation with invalid data"""
        invalid_data = {{
            "name": "",  # Empty name should fail
            "email": "invalid-email",  # Invalid email format
        }}
        
        response = client.post(
            "/{resource_plural}/",
            json=invalid_data,
            headers=auth_headers
        )
        
        assert response.status_code == 422
        assert "detail" in response.json()

class Test{resource_name}BusinessLogic:
    """Test {resource_name} business logic"""
    
    @pytest.fixture
    def db_session(self):
        """Get database session"""
        db = TestingSessionLocal()
        yield db
        db.close()
    
    def test_soft_delete_preserves_data(self, db_session, auth_headers):
        """Test that soft delete doesn't remove data"""
        # Implementation here
        pass
    
    def test_duplicate_prevention(self, db_session, auth_headers):
        """Test duplicate prevention logic"""
        # Implementation here
        pass
    
    def test_cascade_operations(self, db_session, auth_headers):
        """Test cascade operations on related entities"""
        # Implementation here
        pass
''',
                variables=["resource_name", "resource_lower", "resource_plural", "sample_data"],
                dependencies=["pytest", "fastapi", "sqlalchemy"]
            )
        ]
    
    def _get_javascript_react_templates(self) -> List[CodeTemplate]:
        """React component templates"""
        return [
            CodeTemplate(
                name="react_component",
                language="javascript",
                framework="react",
                template_type="component",
                template='''import React, {{ useState, useEffect, useCallback, useMemo }} from 'react';
import {{ useQuery, useMutation, useQueryClient }} from '@tanstack/react-query';
import {{ useForm, Controller }} from 'react-hook-form';
import {{ zodResolver }} from '@hookform/resolvers/zod';
import * as z from 'zod';
import {{
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  TextField,
  IconButton,
  Skeleton,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Chip,
  Menu,
  MenuItem,
}} from '@mui/material';
import {{
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  MoreVert as MoreVertIcon,
  Refresh as RefreshIcon,
}} from '@mui/icons-material';
import {{ {resource_lower}Api }} from '../../api/{resource_lower}';
import {{ useNotification }} from '../../hooks/useNotification';
import {{ useDebounce }} from '../../hooks/useDebounce';
import {{ formatDate }} from '../../utils/dateUtils';

// Validation schema
const {resource_lower}Schema = z.object({{
  name: z.string().min(1, 'Name is required').max(100),
  description: z.string().optional(),
  email: z.string().email('Invalid email').optional(),
  status: z.enum(['active', 'inactive', 'pending']).default('active'),
}});

export const {resource_name}List = () => {{
  const queryClient = useQueryClient();
  const {{ showSuccess, showError }} = useNotification();
  
  // State
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedItem, setSelectedItem] = useState(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [anchorEl, setAnchorEl] = useState(null);
  
  // Debounced search
  const debouncedSearch = useDebounce(searchTerm, 500);
  
  // Queries
  const {{ data, isLoading, error, refetch }} = useQuery({{
    queryKey: ['{resource_plural}', page, rowsPerPage, debouncedSearch],
    queryFn: () => {resource_lower}Api.list({{
      page: page + 1,
      limit: rowsPerPage,
      search: debouncedSearch,
    }}),
    keepPreviousData: true,
  }});
  
  // Mutations
  const createMutation = useMutation({{
    mutationFn: {resource_lower}Api.create,
    onSuccess: () => {{
      showSuccess('{resource_name} created successfully');
      queryClient.invalidateQueries(['{resource_plural}']);
      handleCloseDialog();
    }},
    onError: (error) => {{
      showError(error.message || 'Failed to create {resource_lower}');
    }},
  }});
  
  const updateMutation = useMutation({{
    mutationFn: ({{ id, data }}) => {resource_lower}Api.update(id, data),
    onSuccess: () => {{
      showSuccess('{resource_name} updated successfully');
      queryClient.invalidateQueries(['{resource_plural}']);
      handleCloseDialog();
    }},
    onError: (error) => {{
      showError(error.message || 'Failed to update {resource_lower}');
    }},
  }});
  
  const deleteMutation = useMutation({{
    mutationFn: {resource_lower}Api.delete,
    onSuccess: () => {{
      showSuccess('{resource_name} deleted successfully');
      queryClient.invalidateQueries(['{resource_plural}']);
      setDeleteDialogOpen(false);
    }},
    onError: (error) => {{
      showError(error.message || 'Failed to delete {resource_lower}');
    }},
  }});
  
  // Form
  const {{
    control,
    handleSubmit,
    reset,
    formState: {{ errors }},
  }} = useForm({{
    resolver: zodResolver({resource_lower}Schema),
    defaultValues: {{
      name: '',
      description: '',
      email: '',
      status: 'active',
    }},
  }});
  
  // Handlers
  const handleOpenDialog = (item = null) => {{
    if (item) {{
      setSelectedItem(item);
      reset(item);
    }} else {{
      setSelectedItem(null);
      reset();
    }}
    setDialogOpen(true);
  }};
  
  const handleCloseDialog = () => {{
    setDialogOpen(false);
    setSelectedItem(null);
    reset();
  }};
  
  const handleSubmitForm = (data) => {{
    if (selectedItem) {{
      updateMutation.mutate({{ id: selectedItem.id, data }});
    }} else {{
      createMutation.mutate(data);
    }}
  }};
  
  const handleDelete = () => {{
    if (selectedItem) {{
      deleteMutation.mutate(selectedItem.id);
    }}
  }};
  
  const handleChangePage = (event, newPage) => {{
    setPage(newPage);
  }};
  
  const handleChangeRowsPerPage = (event) => {{
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  }};
  
  // Render helpers
  const renderStatus = (status) => {{
    const colors = {{
      active: 'success',
      inactive: 'default',
      pending: 'warning',
    }};
    
    return (
      <Chip
        label={{status}}
        color={{colors[status] || 'default'}}
        size="small"
      />
    );
  }};
  
  if (error) {{
    return (
      <Alert severity="error">
        Error loading {resource_plural}: {{error.message}}
      </Alert>
    );
  }}
  
  return (
    <Box>
      <Card>
        <CardContent>
          <Box display="flex" justifyContent="space-between" alignItems="center" mb={{2}}>
            <Typography variant="h5">{resource_name} Management</Typography>
            <Box display="flex" gap={{1}}>
              <IconButton onClick={{() => refetch()}}>
                <RefreshIcon />
              </IconButton>
              <Button
                variant="contained"
                startIcon={{<AddIcon />}}
                onClick={{() => handleOpenDialog()}}
              >
                Add {resource_name}
              </Button>
            </Box>
          </Box>
          
          <TextField
            fullWidth
            variant="outlined"
            placeholder="Search {resource_plural}..."
            value={{searchTerm}}
            onChange={{(e) => setSearchTerm(e.target.value)}}
            sx={{{{ mb: 2 }}}}
          />
          
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Name</TableCell>
                  <TableCell>Email</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Created</TableCell>
                  <TableCell align="right">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {{isLoading ? (
                  [...Array(5)].map((_, i) => (
                    <TableRow key={{i}}>
                      <TableCell colSpan={{5}}>
                        <Skeleton />
                      </TableCell>
                    </TableRow>
                  ))
                ) : (
                  data?.items.map((item) => (
                    <TableRow key={{item.id}} hover>
                      <TableCell>{{item.name}}</TableCell>
                      <TableCell>{{item.email || '-'}}</TableCell>
                      <TableCell>{{renderStatus(item.status)}}</TableCell>
                      <TableCell>{{formatDate(item.created_at)}}</TableCell>
                      <TableCell align="right">
                        <IconButton
                          onClick={{(e) => {{
                            setAnchorEl(e.currentTarget);
                            setSelectedItem(item);
                          }}}}
                        >
                          <MoreVertIcon />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))
                )}}
              </TableBody>
            </Table>
          </TableContainer>
          
          <TablePagination
            component="div"
            count={{data?.total || 0}}
            page={{page}}
            onPageChange={{handleChangePage}}
            rowsPerPage={{rowsPerPage}}
            onRowsPerPageChange={{handleChangeRowsPerPage}}
          />
        </CardContent>
      </Card>
      
      {/* Action Menu */}
      <Menu
        anchorEl={{anchorEl}}
        open={{Boolean(anchorEl)}}
        onClose={{() => setAnchorEl(null)}}
      >
        <MenuItem
          onClick={{() => {{
            handleOpenDialog(selectedItem);
            setAnchorEl(null);
          }}}}
        >
          <EditIcon sx={{{{ mr: 1 }}}} /> Edit
        </MenuItem>
        <MenuItem
          onClick={{() => {{
            setDeleteDialogOpen(true);
            setAnchorEl(null);
          }}}}
        >
          <DeleteIcon sx={{{{ mr: 1 }}}} /> Delete
        </MenuItem>
      </Menu>
      
      {/* Create/Edit Dialog */}
      <Dialog open={{dialogOpen}} onClose={{handleCloseDialog}} maxWidth="sm" fullWidth>
        <form onSubmit={{handleSubmit(handleSubmitForm)}}>
          <DialogTitle>
            {{selectedItem ? 'Edit' : 'Create'}} {resource_name}
          </DialogTitle>
          <DialogContent>
            <Box display="flex" flexDirection="column" gap={{2}} mt={{1}}>
              <Controller
                name="name"
                control={{control}}
                render={{({{ field }}) => (
                  <TextField
                    {{...field}}
                    label="Name"
                    fullWidth
                    error={{!!errors.name}}
                    helperText={{errors.name?.message}}
                  />
                )}}
              />
              
              <Controller
                name="email"
                control={{control}}
                render={{({{ field }}) => (
                  <TextField
                    {{...field}}
                    label="Email"
                    type="email"
                    fullWidth
                    error={{!!errors.email}}
                    helperText={{errors.email?.message}}
                  />
                )}}
              />
              
              <Controller
                name="description"
                control={{control}}
                render={{({{ field }}) => (
                  <TextField
                    {{...field}}
                    label="Description"
                    multiline
                    rows={{3}}
                    fullWidth
                    error={{!!errors.description}}
                    helperText={{errors.description?.message}}
                  />
                )}}
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={{handleCloseDialog}}>Cancel</Button>
            <Button
              type="submit"
              variant="contained"
              disabled={{createMutation.isLoading || updateMutation.isLoading}}
            >
              {{selectedItem ? 'Update' : 'Create'}}
            </Button>
          </DialogActions>
        </form>
      </Dialog>
      
      {/* Delete Confirmation Dialog */}
      <Dialog open={{deleteDialogOpen}} onClose={{() => setDeleteDialogOpen(false)}}>
        <DialogTitle>Confirm Delete</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete "{{selectedItem?.name}}"?
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={{() => setDeleteDialogOpen(false)}}>Cancel</Button>
          <Button
            onClick={{handleDelete}}
            color="error"
            variant="contained"
            disabled={{deleteMutation.isLoading}}
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}};

export default {resource_name}List;
''',
                variables=["resource_name", "resource_lower", "resource_plural"],
                dependencies=["react", "@mui/material", "@tanstack/react-query", "react-hook-form", "zod"]
            )
        ]
    
    def _get_sql_templates(self) -> List[CodeTemplate]:
        """SQL templates"""
        return [
            CodeTemplate(
                name="create_table",
                language="sql",
                framework="postgresql",
                template_type="ddl",
                template='''-- Create {resource_name} table
-- Auto-generated by vibe.ai

-- Create enum types
CREATE TYPE {table_name}_status AS ENUM ('active', 'inactive', 'pending', 'archived');

-- Create main table
CREATE TABLE IF NOT EXISTS {table_name} (
    -- Primary key
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Core fields
    {fields}
    
    -- Audit fields
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    created_by UUID REFERENCES users(id),
    updated_by UUID REFERENCES users(id),
    
    -- Soft delete
    deleted_at TIMESTAMP WITH TIME ZONE,
    deleted_by UUID REFERENCES users(id),
    
    -- Constraints
    {constraints}
);

-- Create indexes
CREATE INDEX idx_{table_name}_name ON {table_name}(name) WHERE deleted_at IS NULL;
CREATE INDEX idx_{table_name}_status ON {table_name}(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_{table_name}_created_at ON {table_name}(created_at);
CREATE INDEX idx_{table_name}_deleted_at ON {table_name}(deleted_at);

-- Full text search
CREATE INDEX idx_{table_name}_search ON {table_name} 
    USING gin(to_tsvector('english', coalesce(name, '') || ' ' || coalesce(description, '')));

-- Create update trigger
CREATE OR REPLACE FUNCTION update_{table_name}_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_{table_name}_updated_at
    BEFORE UPDATE ON {table_name}
    FOR EACH ROW
    EXECUTE FUNCTION update_{table_name}_updated_at();

-- Create audit log table
CREATE TABLE IF NOT EXISTS {table_name}_audit (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    {table_name}_id UUID NOT NULL,
    action VARCHAR(10) NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    changed_by UUID REFERENCES users(id),
    changed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    old_values JSONB,
    new_values JSONB
);

-- Create audit trigger
CREATE OR REPLACE FUNCTION audit_{table_name}_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO {table_name}_audit (
            {table_name}_id, action, changed_by, new_values
        ) VALUES (
            NEW.id, 'INSERT', NEW.created_by, to_jsonb(NEW)
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO {table_name}_audit (
            {table_name}_id, action, changed_by, old_values, new_values
        ) VALUES (
            NEW.id, 'UPDATE', NEW.updated_by, to_jsonb(OLD), to_jsonb(NEW)
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO {table_name}_audit (
            {table_name}_id, action, changed_by, old_values
        ) VALUES (
            OLD.id, 'DELETE', OLD.deleted_by, to_jsonb(OLD)
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_audit_{table_name}
    AFTER INSERT OR UPDATE OR DELETE ON {table_name}
    FOR EACH ROW
    EXECUTE FUNCTION audit_{table_name}_changes();

-- Sample data (commented out for production)
/*
INSERT INTO {table_name} (name, email, status, created_by)
VALUES 
    ('Sample 1', 'sample1@example.com', 'active', (SELECT id FROM users LIMIT 1)),
    ('Sample 2', 'sample2@example.com', 'pending', (SELECT id FROM users LIMIT 1)),
    ('Sample 3', 'sample3@example.com', 'inactive', (SELECT id FROM users LIMIT 1));
*/

-- Grants (adjust as needed)
GRANT SELECT, INSERT, UPDATE ON {table_name} TO app_user;
GRANT SELECT ON {table_name}_audit TO app_user;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO app_user;
''',
                variables=["resource_name", "table_name", "fields", "constraints"],
                dependencies=["postgresql"]
            )
        ]
    
    def _get_docker_templates(self) -> List[CodeTemplate]:
        """Docker templates"""
        return [
            CodeTemplate(
                name="dockerfile_python",
                language="dockerfile",
                framework="docker",
                template_type="dockerfile",
                template='''# Multi-stage Dockerfile for {app_name}
# Auto-generated by vibe.ai

# Stage 1: Builder
FROM python:3.11-slim as builder

# Install build dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    g++ \\
    libpq-dev \\
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /build

# Copy requirements
COPY requirements.txt .

# Install Python dependencies
RUN pip install --user --no-cache-dir -r requirements.txt

# Stage 2: Runtime
FROM python:3.11-slim

# Install runtime dependencies
RUN apt-get update && apt-get install -y \\
    libpq5 \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -m -u 1000 -s /bin/bash appuser

# Set working directory
WORKDIR /app

# Copy dependencies from builder
COPY --from=builder /root/.local /home/appuser/.local

# Copy application code
COPY --chown=appuser:appuser . .

# Set environment variables
ENV PATH=/home/appuser/.local/bin:$PATH \\
    PYTHONUNBUFFERED=1 \\
    PYTHONDONTWRITEBYTECODE=1 \\
    PORT=8000

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\
    CMD curl -f http://localhost:8000/health || exit 1

# Run the application
CMD ["python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
''',
                variables=["app_name"],
                dependencies=[]
            ),
            
            CodeTemplate(
                name="docker_compose",
                language="yaml",
                framework="docker",
                template_type="compose",
                template='''version: '3.8'

# Docker Compose for {app_name}
# Auto-generated by vibe.ai

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: {app_name}_postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${{POSTGRES_USER:-postgres}}
      POSTGRES_PASSWORD: ${{POSTGRES_PASSWORD:-postgres}}
      POSTGRES_DB: ${{POSTGRES_DB:-{app_name}_db}}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "${{POSTGRES_PORT:-5432}}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $POSTGRES_USER"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - {app_name}_network

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: {app_name}_redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${{REDIS_PASSWORD:-redis_password}}
    volumes:
      - redis_data:/data
    ports:
      - "${{REDIS_PORT:-6379}}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - {app_name}_network

  # Application
  app:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=${{BUILD_ENV:-production}}
    container_name: {app_name}_app
    restart: unless-stopped
    environment:
      - DATABASE_URL=postgresql://${{POSTGRES_USER:-postgres}}:${{POSTGRES_PASSWORD:-postgres}}@postgres:5432/${{POSTGRES_DB:-{app_name}_db}}
      - REDIS_URL=redis://:${{REDIS_PASSWORD:-redis_password}}@redis:6379/0
      - SECRET_KEY=${{SECRET_KEY:-change_me_in_production}}
      - ENVIRONMENT=${{ENVIRONMENT:-production}}
      - LOG_LEVEL=${{LOG_LEVEL:-INFO}}
    volumes:
      - ./logs:/app/logs
      - ./uploads:/app/uploads
    ports:
      - "${{APP_PORT:-8000}}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - {app_name}_network

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: {app_name}_nginx
    restart: unless-stopped
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./static:/usr/share/nginx/html/static:ro
      - nginx_cache:/var/cache/nginx
    ports:
      - "${{NGINX_PORT:-80}}:80"
      - "${{NGINX_SSL_PORT:-443}}:443"
    depends_on:
      - app
    networks:
      - {app_name}_network

  # Background Worker (if needed)
  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: {app_name}_worker
    restart: unless-stopped
    command: celery -A tasks worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://${{POSTGRES_USER:-postgres}}:${{POSTGRES_PASSWORD:-postgres}}@postgres:5432/${{POSTGRES_DB:-{app_name}_db}}
      - REDIS_URL=redis://:${{REDIS_PASSWORD:-redis_password}}@redis:6379/0
    volumes:
      - ./logs:/app/logs
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - {app_name}_network

  # Monitoring - Prometheus
  prometheus:
    image: prom/prometheus:latest
    container_name: {app_name}_prometheus
    restart: unless-stopped
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    ports:
      - "${{PROMETHEUS_PORT:-9090}}:9090"
    networks:
      - {app_name}_network

  # Monitoring - Grafana
  grafana:
    image: grafana/grafana:latest
    container_name: {app_name}_grafana
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_USER=${{GRAFANA_USER:-admin}}
      - GF_SECURITY_ADMIN_PASSWORD=${{GRAFANA_PASSWORD:-admin}}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
    ports:
      - "${{GRAFANA_PORT:-3000}}:3000"
    depends_on:
      - prometheus
    networks:
      - {app_name}_network

volumes:
  postgres_data:
  redis_data:
  nginx_cache:
  prometheus_data:
  grafana_data:

networks:
  {app_name}_network:
    driver: bridge
''',
                variables=["app_name"],
                dependencies=[]
            )
        ]
    
    def _get_kubernetes_templates(self) -> List[CodeTemplate]:
        """Kubernetes templates"""
        return [
            CodeTemplate(
                name="k8s_deployment",
                language="yaml",
                framework="kubernetes",
                template_type="deployment",
                template='''apiVersion: apps/v1
kind: Deployment
metadata:
  name: {app_name}-deployment
  namespace: {namespace}
  labels:
    app: {app_name}
    version: v1
    component: backend
spec:
  replicas: {replicas}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: {app_name}
      component: backend
  template:
    metadata:
      labels:
        app: {app_name}
        version: v1
        component: backend
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: {app_name}-sa
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
      containers:
      - name: {app_name}
        image: {image_registry}/{app_name}:{image_tag}
        imagePullPolicy: Always
        ports:
        - containerPort: 8000
          name: http
          protocol: TCP
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: {app_name}-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: {app_name}-secrets
              key: redis-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: {app_name}-secrets
              key: secret-key
        - name: ENVIRONMENT
          value: "production"
        - name: LOG_LEVEL
          value: "INFO"
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        resources:
          requests:
            memory: "{memory_request}"
            cpu: "{cpu_request}"
          limits:
            memory: "{memory_limit}"
            cpu: "{cpu_limit}"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /readiness
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
        - name: uploads
          mountPath: /app/uploads
      volumes:
      - name: config
        configMap:
          name: {app_name}-config
      - name: uploads
        persistentVolumeClaim:
          claimName: {app_name}-uploads-pvc
      imagePullSecrets:
      - name: registry-credentials
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - {app_name}
              topologyKey: kubernetes.io/hostname
---
apiVersion: v1
kind: Service
metadata:
  name: {app_name}-service
  namespace: {namespace}
  labels:
    app: {app_name}
    component: backend
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 8000
    protocol: TCP
    name: http
  selector:
    app: {app_name}
    component: backend
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {app_name}-hpa
  namespace: {namespace}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {app_name}-deployment
  minReplicas: {min_replicas}
  maxReplicas: {max_replicas}
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 60
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: {app_name}-pdb
  namespace: {namespace}
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: {app_name}
      component: backend
''',
                variables=[
                    "app_name", "namespace", "replicas", "image_registry", "image_tag",
                    "memory_request", "cpu_request", "memory_limit", "cpu_limit",
                    "min_replicas", "max_replicas"
                ],
                dependencies=[]
            )
        ]
    
    def _get_testing_templates(self) -> List[CodeTemplate]:
        """Testing templates"""
        return [
            CodeTemplate(
                name="pytest_integration_test",
                language="python",
                framework="pytest",
                template_type="test",
                template='''"""
Integration tests for {feature_name}
Auto-generated by vibe.ai
"""

import pytest
import asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Dict, Any
import json

from main import app
from database import get_db
from models import User, {model_name}
from auth.utils import create_access_token
from tests.factories import UserFactory, {model_name}Factory

@pytest.mark.asyncio
class Test{feature_name}Integration:
    """Integration tests for {feature_name}"""
    
    @pytest.fixture
    async def authenticated_client(self, async_client: AsyncClient, test_user: User) -> AsyncClient:
        """Get authenticated client"""
        token = create_access_token({{"sub": str(test_user.id), "email": test_user.email}})
        async_client.headers["Authorization"] = f"Bearer {{token}}"
        return async_client
    
    @pytest.fixture
    async def test_data(self, db_session: AsyncSession) -> Dict[str, Any]:
        """Create test data"""
        # Create test records
        items = []
        for i in range(5):
            item = await {model_name}Factory.create(
                name=f"Test Item {{i}}",
                status="active" if i % 2 == 0 else "inactive"
            )
            items.append(item)
        
        await db_session.commit()
        
        return {{
            "items": items,
            "active_count": 3,
            "inactive_count": 2
        }}
    
    async def test_full_crud_workflow(self, authenticated_client: AsyncClient, db_session: AsyncSession):
        """Test complete CRUD workflow"""
        # 1. Create
        create_data = {{
            "name": "Integration Test Item",
            "description": "Created via integration test",
            "status": "active"
        }}
        
        create_response = await authenticated_client.post(
            "/api/v1/{endpoint}/",
            json=create_data
        )
        assert create_response.status_code == 201
        created_item = create_response.json()
        assert created_item["name"] == create_data["name"]
        item_id = created_item["id"]
        
        # 2. Read
        get_response = await authenticated_client.get(f"/api/v1/{endpoint}/{{item_id}}")
        assert get_response.status_code == 200
        assert get_response.json()["id"] == item_id
        
        # 3. Update
        update_data = {{"name": "Updated Name", "status": "inactive"}}
        update_response = await authenticated_client.put(
            f"/api/v1/{endpoint}/{{item_id}}",
            json=update_data
        )
        assert update_response.status_code == 200
        updated_item = update_response.json()
        assert updated_item["name"] == update_data["name"]
        assert updated_item["status"] == update_data["status"]
        
        # 4. List with filters
        list_response = await authenticated_client.get(
            "/api/v1/{endpoint}/",
            params={{"status": "inactive", "search": "Updated"}}
        )
        assert list_response.status_code == 200
        list_data = list_response.json()
        assert len(list_data["items"]) >= 1
        assert any(item["id"] == item_id for item in list_data["items"])
        
        # 5. Delete
        delete_response = await authenticated_client.delete(f"/api/v1/{endpoint}/{{item_id}}")
        assert delete_response.status_code == 204
        
        # 6. Verify deletion
        get_deleted_response = await authenticated_client.get(f"/api/v1/{endpoint}/{{item_id}}")
        assert get_deleted_response.status_code == 404
    
    async def test_pagination(self, authenticated_client: AsyncClient, test_data: Dict[str, Any]):
        """Test pagination functionality"""
        # Test different page sizes
        page_sizes = [1, 2, 5, 10]
        
        for page_size in page_sizes:
            response = await authenticated_client.get(
                "/api/v1/{endpoint}/",
                params={{"page": 1, "limit": page_size}}
            )
            assert response.status_code == 200
            data = response.json()
            assert len(data["items"]) <= page_size
            assert data["total"] == len(test_data["items"])
            assert data["pages"] == (data["total"] + page_size - 1) // page_size
    
    async def test_filtering(self, authenticated_client: AsyncClient, test_data: Dict[str, Any]):
        """Test filtering functionality"""
        # Test status filter
        response = await authenticated_client.get(
            "/api/v1/{endpoint}/",
            params={{"status": "active"}}
        )
        assert response.status_code == 200
        data = response.json()
        assert all(item["status"] == "active" for item in data["items"])
        assert data["total"] == test_data["active_count"]
        
        # Test search filter
        response = await authenticated_client.get(
            "/api/v1/{endpoint}/",
            params={{"search": "Item 1"}}
        )
        assert response.status_code == 200
        data = response.json()
        assert all("1" in item["name"] for item in data["items"])
    
    async def test_concurrent_operations(self, authenticated_client: AsyncClient):
        """Test concurrent operations don't cause issues"""
        # Create multiple items concurrently
        create_tasks = []
        for i in range(10):
            task = authenticated_client.post(
                "/api/v1/{endpoint}/",
                json={{
                    "name": f"Concurrent Item {{i}}",
                    "status": "active"
                }}
            )
            create_tasks.append(task)
        
        create_results = await asyncio.gather(*create_tasks)
        assert all(r.status_code == 201 for r in create_results)
        
        # Update them concurrently
        update_tasks = []
        for result in create_results:
            item_id = result.json()["id"]
            task = authenticated_client.put(
                f"/api/v1/{endpoint}/{{item_id}}",
                json={{"name": f"Updated {{item_id}}"}}
            )
            update_tasks.append(task)
        
        update_results = await asyncio.gather(*update_tasks)
        assert all(r.status_code == 200 for r in update_results)
    
    async def test_error_handling(self, authenticated_client: AsyncClient):
        """Test error handling scenarios"""
        # Test invalid ID format
        response = await authenticated_client.get("/api/v1/{endpoint}/invalid-id")
        assert response.status_code == 422
        
        # Test non-existent resource
        response = await authenticated_client.get(
            f"/api/v1/{endpoint}/00000000-0000-0000-0000-000000000000"
        )
        assert response.status_code == 404
        
        # Test invalid data
        response = await authenticated_client.post(
            "/api/v1/{endpoint}/",
            json={{
                "name": "",  # Empty name should fail validation
                "status": "invalid_status"
            }}
        )
        assert response.status_code == 422
        assert "detail" in response.json()
    
    async def test_authorization(self, async_client: AsyncClient, test_data: Dict[str, Any]):
        """Test authorization requirements"""
        # Test without authentication
        response = await async_client.get("/api/v1/{endpoint}/")
        assert response.status_code == 401
        
        # Test with invalid token
        async_client.headers["Authorization"] = "Bearer invalid_token"
        response = await async_client.get("/api/v1/{endpoint}/")
        assert response.status_code == 401
    
    async def test_soft_delete_and_restore(self, authenticated_client: AsyncClient):
        """Test soft delete and restore functionality"""
        # Create item
        create_response = await authenticated_client.post(
            "/api/v1/{endpoint}/",
            json={{"name": "To Be Deleted", "status": "active"}}
        )
        item_id = create_response.json()["id"]
        
        # Soft delete
        delete_response = await authenticated_client.delete(f"/api/v1/{endpoint}/{{item_id}}")
        assert delete_response.status_code == 204
        
        # Verify it's not in normal list
        list_response = await authenticated_client.get("/api/v1/{endpoint}/")
        items = list_response.json()["items"]
        assert not any(item["id"] == item_id for item in items)
        
        # Restore
        restore_response = await authenticated_client.post(
            f"/api/v1/{endpoint}/{{item_id}}/restore"
        )
        assert restore_response.status_code == 200
        
        # Verify it's back
        get_response = await authenticated_client.get(f"/api/v1/{endpoint}/{{item_id}}")
        assert get_response.status_code == 200
    
    @pytest.mark.performance
    async def test_performance(self, authenticated_client: AsyncClient, test_data: Dict[str, Any]):
        """Test performance requirements"""
        import time
        
        # Test list endpoint performance
        start_time = time.time()
        response = await authenticated_client.get("/api/v1/{endpoint}/")
        end_time = time.time()
        
        assert response.status_code == 200
        assert (end_time - start_time) < 0.5  # Should respond within 500ms
        
        # Test search performance
        start_time = time.time()
        response = await authenticated_client.get(
            "/api/v1/{endpoint}/",
            params={{"search": "test", "status": "active"}}
        )
        end_time = time.time()
        
        assert response.status_code == 200
        assert (end_time - start_time) < 0.5  # Search should also be fast
''',
                variables=["feature_name", "model_name", "endpoint"],
                dependencies=["pytest", "pytest-asyncio", "httpx", "sqlalchemy", "factory-boy"]
            )
        ]
    
    def _get_python_django_templates(self) -> List[CodeTemplate]:
        """Django templates"""
        # TODO: Add Django templates
        return []
    
    def _get_javascript_express_templates(self) -> List[CodeTemplate]:
        """Express.js templates"""
        # TODO: Add Express templates
        return []
    
    def _get_go_gin_templates(self) -> List[CodeTemplate]:
        """Go Gin templates"""
        # TODO: Add Go templates
        return []
    
    def _get_rust_actix_templates(self) -> List[CodeTemplate]:
        """Rust Actix templates"""
        # TODO: Add Rust templates
        return []
    
    def get_template(self, framework: str, template_type: str) -> Optional[CodeTemplate]:
        """Get a specific template"""
        if framework in self.templates:
            for template in self.templates[framework]:
                if template.template_type == template_type:
                    return template
        return None
    
    def get_templates_by_framework(self, framework: str) -> List[CodeTemplate]:
        """Get all templates for a framework"""
        return self.templates.get(framework, [])
    
    def generate_code(self, framework: str, template_type: str, 
                     context: Dict[str, Any]) -> Optional[str]:
        """Generate code using a template"""
        template = self.get_template(framework, template_type)
        if template:
            return template.render(context)
        return None


# Usage example
if __name__ == "__main__":
    generator = CodeGenerationTemplates()
    
    # Example: Generate FastAPI CRUD router
    context = {
        "resource_name": "Product",
        "resource_lower": "product",
        "resource_plural": "products"
    }
    
    code = generator.generate_code("python_fastapi", "api", context)
    if code:
        print("Generated FastAPI Router:")
        print(code[:500] + "...")  # Print first 500 chars
    
    # List available templates
    print("\nAvailable Templates:")
    for framework, templates in generator.templates.items():
        print(f"\n{framework}:")
        for template in templates:
            print(f"  - {template.name} ({template.template_type})")